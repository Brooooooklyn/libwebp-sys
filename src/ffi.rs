/* automatically generated by rust-bindgen */

pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\x00";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\x00";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\x00";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\x00";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\x00";
pub const PRId8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIo8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRId16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIi16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIo16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIu16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIx16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIX16: &'static [u8; 3usize] = b"hX\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRId64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIi64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIo64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIu64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIx64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIX64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\x00";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\x00";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\x00";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\x00";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\x00";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\x00";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNd64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNi64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNo64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNu64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNx64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\x00";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\x00";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\x00";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\x00";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\x00";
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __MAC_10_12: ::std::os::raw::c_uint = 101200;
pub const __MAC_10_12_1: ::std::os::raw::c_uint = 101201;
pub const __MAC_10_12_2: ::std::os::raw::c_uint = 101202;
pub const __MAC_10_12_4: ::std::os::raw::c_uint = 101204;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __IPHONE_10_0: ::std::os::raw::c_uint = 100000;
pub const __IPHONE_10_1: ::std::os::raw::c_uint = 100100;
pub const __IPHONE_10_2: ::std::os::raw::c_uint = 100200;
pub const __IPHONE_10_3: ::std::os::raw::c_uint = 100300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __TVOS_10_0: ::std::os::raw::c_uint = 100000;
pub const __TVOS_10_0_1: ::std::os::raw::c_uint = 100001;
pub const __TVOS_10_1: ::std::os::raw::c_uint = 100100;
pub const __TVOS_10_2: ::std::os::raw::c_uint = 100200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __WATCHOS_2_1: ::std::os::raw::c_uint = 20100;
pub const __WATCHOS_2_2: ::std::os::raw::c_uint = 20200;
pub const __WATCHOS_3_0: ::std::os::raw::c_uint = 30000;
pub const __WATCHOS_3_1: ::std::os::raw::c_uint = 30100;
pub const __WATCHOS_3_1_1: ::std::os::raw::c_uint = 30101;
pub const __WATCHOS_3_2: ::std::os::raw::c_uint = 30200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101204;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const WEBP_ENCODER_ABI_VERSION: ::std::os::raw::c_uint = 526;
pub const WEBP_MAX_DIMENSION: ::std::os::raw::c_uint = 16383;
pub const WEBP_DECODER_ABI_VERSION: ::std::os::raw::c_uint = 520;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPConfig {
    pub lossless: ::std::os::raw::c_int,
    pub quality: f32,
    pub method: ::std::os::raw::c_int,
    pub image_hint: WebPImageHint,
    pub target_size: ::std::os::raw::c_int,
    pub target_PSNR: f32,
    pub segments: ::std::os::raw::c_int,
    pub sns_strength: ::std::os::raw::c_int,
    pub filter_strength: ::std::os::raw::c_int,
    pub filter_sharpness: ::std::os::raw::c_int,
    pub filter_type: ::std::os::raw::c_int,
    pub autofilter: ::std::os::raw::c_int,
    pub alpha_compression: ::std::os::raw::c_int,
    pub alpha_filtering: ::std::os::raw::c_int,
    pub alpha_quality: ::std::os::raw::c_int,
    pub pass: ::std::os::raw::c_int,
    pub show_compressed: ::std::os::raw::c_int,
    pub preprocessing: ::std::os::raw::c_int,
    pub partitions: ::std::os::raw::c_int,
    pub partition_limit: ::std::os::raw::c_int,
    pub emulate_jpeg_size: ::std::os::raw::c_int,
    pub thread_level: ::std::os::raw::c_int,
    pub low_memory: ::std::os::raw::c_int,
    pub near_lossless: ::std::os::raw::c_int,
    pub exact: ::std::os::raw::c_int,
    pub use_delta_palette: ::std::os::raw::c_int,
    pub use_sharp_yuv: ::std::os::raw::c_int,
    pub pad: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_WebPConfig() {
    assert_eq!(::std::mem::size_of::<WebPConfig>() , 116usize , concat ! (
               "Size of: " , stringify ! ( WebPConfig ) ));
    assert_eq! (::std::mem::align_of::<WebPConfig>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( WebPConfig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . lossless as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( lossless ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . quality as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( quality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . method as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . image_hint as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( image_hint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . target_size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( target_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . target_PSNR as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( target_PSNR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . segments as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( segments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . sns_strength as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( sns_strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . filter_strength as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( filter_strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . filter_sharpness as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( filter_sharpness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . filter_type as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( filter_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . autofilter as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( autofilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . alpha_compression as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( alpha_compression ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . alpha_filtering as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( alpha_filtering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . alpha_quality as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( alpha_quality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . pass as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( pass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . show_compressed as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( show_compressed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . preprocessing as * const
                _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( preprocessing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . partitions as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( partitions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . partition_limit as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( partition_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . emulate_jpeg_size as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( emulate_jpeg_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . thread_level as * const
                _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( thread_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . low_memory as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( low_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . near_lossless as * const
                _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( near_lossless ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . exact as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( exact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . use_delta_palette as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( use_delta_palette ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . use_sharp_yuv as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( use_sharp_yuv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPConfig ) ) . pad as * const _ as
                usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPConfig ) , "::" ,
                stringify ! ( pad ) ));
}
impl Clone for WebPConfig {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPPicture {
    ///
    pub use_argb: ::std::os::raw::c_int,
    pub colorspace: WebPEncCSP,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub y: *mut u8,
    pub u: *mut u8,
    pub v: *mut u8,
    pub y_stride: ::std::os::raw::c_int,
    pub uv_stride: ::std::os::raw::c_int,
    pub a: *mut u8,
    pub a_stride: ::std::os::raw::c_int,
    pub pad1: [u32; 2usize],
    pub argb: *mut u32,
    pub argb_stride: ::std::os::raw::c_int,
    pub pad2: [u32; 3usize],
    ///
    pub writer: WebPWriterFunction,
    pub custom_ptr: *mut ::std::os::raw::c_void,
    pub extra_info_type: ::std::os::raw::c_int,
    pub extra_info: *mut u8,
    ///
    pub stats: *mut WebPAuxStats,
    pub error_code: WebPEncodingError,
    pub progress_hook: WebPProgressHook,
    pub user_data: *mut ::std::os::raw::c_void,
    pub pad3: [u32; 3usize],
    pub pad4: *mut u8,
    pub pad5: *mut u8,
    pub pad6: [u32; 8usize],
    ///
    pub memory_: *mut ::std::os::raw::c_void,
    pub memory_argb_: *mut ::std::os::raw::c_void,
    pub pad7: [*mut ::std::os::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_WebPPicture() {
    assert_eq!(::std::mem::size_of::<WebPPicture>() , 256usize , concat ! (
               "Size of: " , stringify ! ( WebPPicture ) ));
    assert_eq! (::std::mem::align_of::<WebPPicture>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WebPPicture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . use_argb as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( use_argb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . colorspace as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( colorspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . width as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . height as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . y as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . u as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . v as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . y_stride as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( y_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . uv_stride as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( uv_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . a as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . a_stride as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( a_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . pad1 as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . argb as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( argb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . argb_stride as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( argb_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . pad2 as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . writer as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . custom_ptr as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( custom_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . extra_info_type as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( extra_info_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . extra_info as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( extra_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . stats as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . error_code as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( error_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . progress_hook as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( progress_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . user_data as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( user_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . pad3 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . pad6 as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( pad6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . memory_ as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( memory_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . memory_argb_ as * const
                _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( memory_argb_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPPicture ) ) . pad7 as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPPicture ) , "::" ,
                stringify ! ( pad7 ) ));
}
impl Clone for WebPPicture {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPAuxStats {
    pub coded_size: ::std::os::raw::c_int,
    pub PSNR: [f32; 5usize],
    pub block_count: [::std::os::raw::c_int; 3usize],
    pub header_bytes: [::std::os::raw::c_int; 2usize],
    pub residual_bytes: [[::std::os::raw::c_int; 4usize]; 3usize],
    pub segment_size: [::std::os::raw::c_int; 4usize],
    pub segment_quant: [::std::os::raw::c_int; 4usize],
    pub segment_level: [::std::os::raw::c_int; 4usize],
    pub alpha_data_size: ::std::os::raw::c_int,
    pub layer_data_size: ::std::os::raw::c_int,
    pub lossless_features: u32,
    pub histogram_bits: ::std::os::raw::c_int,
    pub transform_bits: ::std::os::raw::c_int,
    pub cache_bits: ::std::os::raw::c_int,
    pub palette_size: ::std::os::raw::c_int,
    pub lossless_size: ::std::os::raw::c_int,
    pub lossless_hdr_size: ::std::os::raw::c_int,
    pub lossless_data_size: ::std::os::raw::c_int,
    pub pad: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_WebPAuxStats() {
    assert_eq!(::std::mem::size_of::<WebPAuxStats>() , 188usize , concat ! (
               "Size of: " , stringify ! ( WebPAuxStats ) ));
    assert_eq! (::std::mem::align_of::<WebPAuxStats>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( WebPAuxStats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . coded_size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( coded_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . PSNR as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( PSNR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . block_count as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( block_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . header_bytes as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( header_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . residual_bytes as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( residual_bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . segment_size as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( segment_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . segment_quant as *
                const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( segment_quant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . segment_level as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( segment_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . alpha_data_size as *
                const _ as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( alpha_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . layer_data_size as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( layer_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . lossless_features as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( lossless_features ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . histogram_bits as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( histogram_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . transform_bits as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( transform_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . cache_bits as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( cache_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . palette_size as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( palette_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . lossless_size as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( lossless_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . lossless_hdr_size as *
                const _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( lossless_hdr_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . lossless_data_size as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( lossless_data_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPAuxStats ) ) . pad as * const _ as
                usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPAuxStats ) , "::" ,
                stringify ! ( pad ) ));
}
impl Clone for WebPAuxStats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPMemoryWriter {
    pub mem: *mut u8,
    pub size: usize,
    pub max_size: usize,
    pub pad: [u32; 1usize],
}
#[test]
fn bindgen_test_layout_WebPMemoryWriter() {
    assert_eq!(::std::mem::size_of::<WebPMemoryWriter>() , 32usize , concat !
               ( "Size of: " , stringify ! ( WebPMemoryWriter ) ));
    assert_eq! (::std::mem::align_of::<WebPMemoryWriter>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( WebPMemoryWriter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPMemoryWriter ) ) . mem as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPMemoryWriter ) ,
                "::" , stringify ! ( mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPMemoryWriter ) ) . size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPMemoryWriter ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPMemoryWriter ) ) . max_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPMemoryWriter ) ,
                "::" , stringify ! ( max_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPMemoryWriter ) ) . pad as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPMemoryWriter ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for WebPMemoryWriter {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn WebPGetEncoderVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPEncodeRGB(rgb: *const u8, width: ::std::os::raw::c_int,
                         height: ::std::os::raw::c_int,
                         stride: ::std::os::raw::c_int, quality_factor: f32,
                         output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPEncodeBGR(bgr: *const u8, width: ::std::os::raw::c_int,
                         height: ::std::os::raw::c_int,
                         stride: ::std::os::raw::c_int, quality_factor: f32,
                         output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPEncodeRGBA(rgba: *const u8, width: ::std::os::raw::c_int,
                          height: ::std::os::raw::c_int,
                          stride: ::std::os::raw::c_int, quality_factor: f32,
                          output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPEncodeBGRA(bgra: *const u8, width: ::std::os::raw::c_int,
                          height: ::std::os::raw::c_int,
                          stride: ::std::os::raw::c_int, quality_factor: f32,
                          output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessRGB(rgb: *const u8, width: ::std::os::raw::c_int,
                                 height: ::std::os::raw::c_int,
                                 stride: ::std::os::raw::c_int,
                                 output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessBGR(bgr: *const u8, width: ::std::os::raw::c_int,
                                 height: ::std::os::raw::c_int,
                                 stride: ::std::os::raw::c_int,
                                 output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessRGBA(rgba: *const u8,
                                  width: ::std::os::raw::c_int,
                                  height: ::std::os::raw::c_int,
                                  stride: ::std::os::raw::c_int,
                                  output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPEncodeLosslessBGRA(bgra: *const u8,
                                  width: ::std::os::raw::c_int,
                                  height: ::std::os::raw::c_int,
                                  stride: ::std::os::raw::c_int,
                                  output: *mut *mut u8) -> usize;
}
extern "C" {
    pub fn WebPFree(ptr: *mut ::std::os::raw::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WebPImageHint {
    WEBP_HINT_DEFAULT = 0,
    WEBP_HINT_PICTURE = 1,
    WEBP_HINT_PHOTO = 2,
    WEBP_HINT_GRAPH = 3,
    WEBP_HINT_LAST = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WebPPreset {
    WEBP_PRESET_DEFAULT = 0,
    WEBP_PRESET_PICTURE = 1,
    WEBP_PRESET_PHOTO = 2,
    WEBP_PRESET_DRAWING = 3,
    WEBP_PRESET_ICON = 4,
    WEBP_PRESET_TEXT = 5,
}
extern "C" {
    pub fn WebPConfigInitInternal(arg1: *mut WebPConfig, arg2: WebPPreset,
                                  arg3: f32, arg4: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPConfigLosslessPreset(config: *mut WebPConfig,
                                    level: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPValidateConfig(config: *const WebPConfig)
     -> ::std::os::raw::c_int;
}
pub type WebPWriterFunction =
    ::std::option::Option<unsafe extern "C" fn(data: *const u8,
                                               data_size: usize,
                                               picture: *const WebPPicture)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn WebPMemoryWriterInit(writer: *mut WebPMemoryWriter);
}
extern "C" {
    pub fn WebPMemoryWriterClear(writer: *mut WebPMemoryWriter);
}
extern "C" {
    pub fn WebPMemoryWrite(data: *const u8, data_size: usize,
                           picture: *const WebPPicture)
     -> ::std::os::raw::c_int;
}
pub type WebPProgressHook =
    ::std::option::Option<unsafe extern "C" fn(percent: ::std::os::raw::c_int,
                                               picture: *const WebPPicture)
                              -> ::std::os::raw::c_int>;
pub const WebPEncCSP_WEBP_CSP_ALPHA_BIT: WebPEncCSP =
    WebPEncCSP::WEBP_YUV420A;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WebPEncCSP {
    WEBP_YUV420 = 0,
    WEBP_YUV420A = 4,
    WEBP_CSP_UV_MASK = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WebPEncodingError {
    VP8_ENC_OK = 0,
    VP8_ENC_ERROR_OUT_OF_MEMORY = 1,
    VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 2,
    VP8_ENC_ERROR_NULL_PARAMETER = 3,
    VP8_ENC_ERROR_INVALID_CONFIGURATION = 4,
    VP8_ENC_ERROR_BAD_DIMENSION = 5,
    VP8_ENC_ERROR_PARTITION0_OVERFLOW = 6,
    VP8_ENC_ERROR_PARTITION_OVERFLOW = 7,
    VP8_ENC_ERROR_BAD_WRITE = 8,
    VP8_ENC_ERROR_FILE_TOO_BIG = 9,
    VP8_ENC_ERROR_USER_ABORT = 10,
    VP8_ENC_ERROR_LAST = 11,
}
extern "C" {
    pub fn WebPPictureInitInternal(arg1: *mut WebPPicture,
                                   arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureAlloc(picture: *mut WebPPicture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureFree(picture: *mut WebPPicture);
}
extern "C" {
    pub fn WebPPictureCopy(src: *const WebPPicture, dst: *mut WebPPicture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPlaneDistortion(src: *const u8, src_stride: usize,
                               ref_: *const u8, ref_stride: usize,
                               width: ::std::os::raw::c_int,
                               height: ::std::os::raw::c_int, x_step: usize,
                               type_: ::std::os::raw::c_int,
                               distortion: *mut f32, result: *mut f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureDistortion(src: *const WebPPicture,
                                 ref_: *const WebPPicture,
                                 metric_type: ::std::os::raw::c_int,
                                 result: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureCrop(picture: *mut WebPPicture,
                           left: ::std::os::raw::c_int,
                           top: ::std::os::raw::c_int,
                           width: ::std::os::raw::c_int,
                           height: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureView(src: *const WebPPicture,
                           left: ::std::os::raw::c_int,
                           top: ::std::os::raw::c_int,
                           width: ::std::os::raw::c_int,
                           height: ::std::os::raw::c_int,
                           dst: *mut WebPPicture) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureIsView(picture: *const WebPPicture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureRescale(pic: *mut WebPPicture,
                              width: ::std::os::raw::c_int,
                              height: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureImportRGB(picture: *mut WebPPicture, rgb: *const u8,
                                rgb_stride: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureImportRGBA(picture: *mut WebPPicture, rgba: *const u8,
                                 rgba_stride: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureImportRGBX(picture: *mut WebPPicture, rgbx: *const u8,
                                 rgbx_stride: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureImportBGR(picture: *mut WebPPicture, bgr: *const u8,
                                bgr_stride: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureImportBGRA(picture: *mut WebPPicture, bgra: *const u8,
                                 bgra_stride: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureImportBGRX(picture: *mut WebPPicture, bgrx: *const u8,
                                 bgrx_stride: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureARGBToYUVA(picture: *mut WebPPicture, arg1: WebPEncCSP)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureARGBToYUVADithered(picture: *mut WebPPicture,
                                         colorspace: WebPEncCSP,
                                         dithering: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureSharpARGBToYUVA(picture: *mut WebPPicture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureSmartARGBToYUVA(picture: *mut WebPPicture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPPictureYUVAToARGB(picture: *mut WebPPicture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPCleanupTransparentArea(picture: *mut WebPPicture);
}
extern "C" {
    pub fn WebPPictureHasTransparency(picture: *const WebPPicture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPBlendAlpha(pic: *mut WebPPicture, background_rgb: u32);
}
extern "C" {
    pub fn WebPEncode(config: *const WebPConfig, picture: *mut WebPPicture)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPRGBABuffer {
    pub rgba: *mut u8,
    pub stride: ::std::os::raw::c_int,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_WebPRGBABuffer() {
    assert_eq!(::std::mem::size_of::<WebPRGBABuffer>() , 24usize , concat ! (
               "Size of: " , stringify ! ( WebPRGBABuffer ) ));
    assert_eq! (::std::mem::align_of::<WebPRGBABuffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WebPRGBABuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPRGBABuffer ) ) . rgba as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPRGBABuffer ) , "::"
                , stringify ! ( rgba ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPRGBABuffer ) ) . stride as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPRGBABuffer ) , "::"
                , stringify ! ( stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPRGBABuffer ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPRGBABuffer ) , "::"
                , stringify ! ( size ) ));
}
impl Clone for WebPRGBABuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPYUVABuffer {
    pub y: *mut u8,
    pub u: *mut u8,
    pub v: *mut u8,
    pub a: *mut u8,
    pub y_stride: ::std::os::raw::c_int,
    pub u_stride: ::std::os::raw::c_int,
    pub v_stride: ::std::os::raw::c_int,
    pub a_stride: ::std::os::raw::c_int,
    pub y_size: usize,
    pub u_size: usize,
    pub v_size: usize,
    pub a_size: usize,
}
#[test]
fn bindgen_test_layout_WebPYUVABuffer() {
    assert_eq!(::std::mem::size_of::<WebPYUVABuffer>() , 80usize , concat ! (
               "Size of: " , stringify ! ( WebPYUVABuffer ) ));
    assert_eq! (::std::mem::align_of::<WebPYUVABuffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WebPYUVABuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . y as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . u as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . v as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . a as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . y_stride as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( y_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . u_stride as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( u_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . v_stride as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( v_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . a_stride as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( a_stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . y_size as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( y_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . u_size as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( u_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . v_size as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( v_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPYUVABuffer ) ) . a_size as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPYUVABuffer ) , "::"
                , stringify ! ( a_size ) ));
}
impl Clone for WebPYUVABuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WebPDecBuffer {
    pub colorspace: WEBP_CSP_MODE,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub is_external_memory: ::std::os::raw::c_int,
    pub u: WebPDecBuffer__bindgen_ty_1,
    pub pad: [u32; 4usize],
    pub private_memory: *mut u8,
}
#[repr(C)]
#[derive(Copy)]
pub union WebPDecBuffer__bindgen_ty_1 {
    pub RGBA: WebPRGBABuffer,
    pub YUVA: WebPYUVABuffer,
    _bindgen_union_align: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_WebPDecBuffer__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<WebPDecBuffer__bindgen_ty_1>() , 80usize
               , concat ! (
               "Size of: " , stringify ! ( WebPDecBuffer__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<WebPDecBuffer__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( WebPDecBuffer__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer__bindgen_ty_1 ) ) . RGBA as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                WebPDecBuffer__bindgen_ty_1 ) , "::" , stringify ! ( RGBA )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer__bindgen_ty_1 ) ) . YUVA as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                WebPDecBuffer__bindgen_ty_1 ) , "::" , stringify ! ( YUVA )
                ));
}
impl Clone for WebPDecBuffer__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_WebPDecBuffer() {
    assert_eq!(::std::mem::size_of::<WebPDecBuffer>() , 120usize , concat ! (
               "Size of: " , stringify ! ( WebPDecBuffer ) ));
    assert_eq! (::std::mem::align_of::<WebPDecBuffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( WebPDecBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer ) ) . colorspace as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecBuffer ) , "::"
                , stringify ! ( colorspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer ) ) . width as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecBuffer ) , "::"
                , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer ) ) . height as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecBuffer ) , "::"
                , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer ) ) . is_external_memory as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecBuffer ) , "::"
                , stringify ! ( is_external_memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer ) ) . u as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecBuffer ) , "::"
                , stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer ) ) . pad as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecBuffer ) , "::"
                , stringify ! ( pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecBuffer ) ) . private_memory as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecBuffer ) , "::"
                , stringify ! ( private_memory ) ));
}
impl Clone for WebPDecBuffer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WebPIDecoder {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPBitstreamFeatures {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub has_alpha: ::std::os::raw::c_int,
    pub has_animation: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
    pub pad: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_WebPBitstreamFeatures() {
    assert_eq!(::std::mem::size_of::<WebPBitstreamFeatures>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( WebPBitstreamFeatures )
               ));
    assert_eq! (::std::mem::align_of::<WebPBitstreamFeatures>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( WebPBitstreamFeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPBitstreamFeatures ) ) . width as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPBitstreamFeatures )
                , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPBitstreamFeatures ) ) . height as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPBitstreamFeatures )
                , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPBitstreamFeatures ) ) . has_alpha as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPBitstreamFeatures )
                , "::" , stringify ! ( has_alpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPBitstreamFeatures ) ) . has_animation
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPBitstreamFeatures )
                , "::" , stringify ! ( has_animation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPBitstreamFeatures ) ) . format as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPBitstreamFeatures )
                , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPBitstreamFeatures ) ) . pad as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPBitstreamFeatures )
                , "::" , stringify ! ( pad ) ));
}
impl Clone for WebPBitstreamFeatures {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WebPDecoderOptions {
    pub bypass_filtering: ::std::os::raw::c_int,
    pub no_fancy_upsampling: ::std::os::raw::c_int,
    pub use_cropping: ::std::os::raw::c_int,
    pub crop_left: ::std::os::raw::c_int,
    pub crop_top: ::std::os::raw::c_int,
    pub crop_width: ::std::os::raw::c_int,
    pub crop_height: ::std::os::raw::c_int,
    pub use_scaling: ::std::os::raw::c_int,
    pub scaled_width: ::std::os::raw::c_int,
    pub scaled_height: ::std::os::raw::c_int,
    pub use_threads: ::std::os::raw::c_int,
    pub dithering_strength: ::std::os::raw::c_int,
    pub flip: ::std::os::raw::c_int,
    pub alpha_dithering_strength: ::std::os::raw::c_int,
    pub pad: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_WebPDecoderOptions() {
    assert_eq!(::std::mem::size_of::<WebPDecoderOptions>() , 76usize , concat
               ! ( "Size of: " , stringify ! ( WebPDecoderOptions ) ));
    assert_eq! (::std::mem::align_of::<WebPDecoderOptions>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( WebPDecoderOptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . bypass_filtering
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( bypass_filtering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) .
                no_fancy_upsampling as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( no_fancy_upsampling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . use_cropping as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( use_cropping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . crop_left as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( crop_left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . crop_top as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( crop_top ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . crop_width as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( crop_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . crop_height as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( crop_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . use_scaling as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( use_scaling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . scaled_width as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( scaled_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . scaled_height as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( scaled_height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . use_threads as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( use_threads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) .
                dithering_strength as * const _ as usize } , 44usize , concat
                ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( dithering_strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . flip as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( flip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) .
                alpha_dithering_strength as * const _ as usize } , 52usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( alpha_dithering_strength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderOptions ) ) . pad as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderOptions ) ,
                "::" , stringify ! ( pad ) ));
}
impl Clone for WebPDecoderOptions {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct WebPDecoderConfig {
    pub input: WebPBitstreamFeatures,
    pub output: WebPDecBuffer,
    pub options: WebPDecoderOptions,
}
#[test]
fn bindgen_test_layout_WebPDecoderConfig() {
    assert_eq!(::std::mem::size_of::<WebPDecoderConfig>() , 240usize , concat
               ! ( "Size of: " , stringify ! ( WebPDecoderConfig ) ));
    assert_eq! (::std::mem::align_of::<WebPDecoderConfig>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( WebPDecoderConfig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderConfig ) ) . input as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderConfig ) ,
                "::" , stringify ! ( input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderConfig ) ) . output as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderConfig ) ,
                "::" , stringify ! ( output ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const WebPDecoderConfig ) ) . options as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( WebPDecoderConfig ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for WebPDecoderConfig {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn WebPGetDecoderVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPGetInfo(data: *const u8, data_size: usize,
                       width: *mut ::std::os::raw::c_int,
                       height: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPDecodeRGBA(data: *const u8, data_size: usize,
                          width: *mut ::std::os::raw::c_int,
                          height: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeARGB(data: *const u8, data_size: usize,
                          width: *mut ::std::os::raw::c_int,
                          height: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGRA(data: *const u8, data_size: usize,
                          width: *mut ::std::os::raw::c_int,
                          height: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeRGB(data: *const u8, data_size: usize,
                         width: *mut ::std::os::raw::c_int,
                         height: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGR(data: *const u8, data_size: usize,
                         width: *mut ::std::os::raw::c_int,
                         height: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeYUV(data: *const u8, data_size: usize,
                         width: *mut ::std::os::raw::c_int,
                         height: *mut ::std::os::raw::c_int, u: *mut *mut u8,
                         v: *mut *mut u8, stride: *mut ::std::os::raw::c_int,
                         uv_stride: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeRGBAInto(data: *const u8, data_size: usize,
                              output_buffer: *mut u8,
                              output_buffer_size: usize,
                              output_stride: ::std::os::raw::c_int)
     -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeARGBInto(data: *const u8, data_size: usize,
                              output_buffer: *mut u8,
                              output_buffer_size: usize,
                              output_stride: ::std::os::raw::c_int)
     -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGRAInto(data: *const u8, data_size: usize,
                              output_buffer: *mut u8,
                              output_buffer_size: usize,
                              output_stride: ::std::os::raw::c_int)
     -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeRGBInto(data: *const u8, data_size: usize,
                             output_buffer: *mut u8,
                             output_buffer_size: usize,
                             output_stride: ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeBGRInto(data: *const u8, data_size: usize,
                             output_buffer: *mut u8,
                             output_buffer_size: usize,
                             output_stride: ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPDecodeYUVInto(data: *const u8, data_size: usize, luma: *mut u8,
                             luma_size: usize,
                             luma_stride: ::std::os::raw::c_int, u: *mut u8,
                             u_size: usize, u_stride: ::std::os::raw::c_int,
                             v: *mut u8, v_size: usize,
                             v_stride: ::std::os::raw::c_int) -> *mut u8;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WEBP_CSP_MODE {
    MODE_RGB = 0,
    MODE_RGBA = 1,
    MODE_BGR = 2,
    MODE_BGRA = 3,
    MODE_ARGB = 4,
    MODE_RGBA_4444 = 5,
    MODE_RGB_565 = 6,
    MODE_rgbA = 7,
    MODE_bgrA = 8,
    MODE_Argb = 9,
    MODE_rgbA_4444 = 10,
    MODE_YUV = 11,
    MODE_YUVA = 12,
    MODE_LAST = 13,
}
extern "C" {
    pub fn WebPInitDecBufferInternal(arg1: *mut WebPDecBuffer,
                                     arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPFreeDecBuffer(buffer: *mut WebPDecBuffer);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VP8StatusCode {
    VP8_STATUS_OK = 0,
    VP8_STATUS_OUT_OF_MEMORY = 1,
    VP8_STATUS_INVALID_PARAM = 2,
    VP8_STATUS_BITSTREAM_ERROR = 3,
    VP8_STATUS_UNSUPPORTED_FEATURE = 4,
    VP8_STATUS_SUSPENDED = 5,
    VP8_STATUS_USER_ABORT = 6,
    VP8_STATUS_NOT_ENOUGH_DATA = 7,
}
extern "C" {
    pub fn WebPINewDecoder(output_buffer: *mut WebPDecBuffer)
     -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPINewRGB(csp: WEBP_CSP_MODE, output_buffer: *mut u8,
                       output_buffer_size: usize,
                       output_stride: ::std::os::raw::c_int)
     -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPINewYUVA(luma: *mut u8, luma_size: usize,
                        luma_stride: ::std::os::raw::c_int, u: *mut u8,
                        u_size: usize, u_stride: ::std::os::raw::c_int,
                        v: *mut u8, v_size: usize,
                        v_stride: ::std::os::raw::c_int, a: *mut u8,
                        a_size: usize, a_stride: ::std::os::raw::c_int)
     -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPINewYUV(luma: *mut u8, luma_size: usize,
                       luma_stride: ::std::os::raw::c_int, u: *mut u8,
                       u_size: usize, u_stride: ::std::os::raw::c_int,
                       v: *mut u8, v_size: usize,
                       v_stride: ::std::os::raw::c_int) -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPIDelete(idec: *mut WebPIDecoder);
}
extern "C" {
    pub fn WebPIAppend(idec: *mut WebPIDecoder, data: *const u8,
                       data_size: usize) -> VP8StatusCode;
}
extern "C" {
    pub fn WebPIUpdate(idec: *mut WebPIDecoder, data: *const u8,
                       data_size: usize) -> VP8StatusCode;
}
extern "C" {
    pub fn WebPIDecGetRGB(idec: *const WebPIDecoder,
                          last_y: *mut ::std::os::raw::c_int,
                          width: *mut ::std::os::raw::c_int,
                          height: *mut ::std::os::raw::c_int,
                          stride: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPIDecGetYUVA(idec: *const WebPIDecoder,
                           last_y: *mut ::std::os::raw::c_int,
                           u: *mut *mut u8, v: *mut *mut u8, a: *mut *mut u8,
                           width: *mut ::std::os::raw::c_int,
                           height: *mut ::std::os::raw::c_int,
                           stride: *mut ::std::os::raw::c_int,
                           uv_stride: *mut ::std::os::raw::c_int,
                           a_stride: *mut ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn WebPIDecodedArea(idec: *const WebPIDecoder,
                            left: *mut ::std::os::raw::c_int,
                            top: *mut ::std::os::raw::c_int,
                            width: *mut ::std::os::raw::c_int,
                            height: *mut ::std::os::raw::c_int)
     -> *const WebPDecBuffer;
}
extern "C" {
    pub fn WebPGetFeaturesInternal(arg1: *const u8, arg2: usize,
                                   arg3: *mut WebPBitstreamFeatures,
                                   arg4: ::std::os::raw::c_int)
     -> VP8StatusCode;
}
extern "C" {
    pub fn WebPInitDecoderConfigInternal(arg1: *mut WebPDecoderConfig,
                                         arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WebPIDecode(data: *const u8, data_size: usize,
                       config: *mut WebPDecoderConfig) -> *mut WebPIDecoder;
}
extern "C" {
    pub fn WebPDecode(data: *const u8, data_size: usize,
                      config: *mut WebPDecoderConfig) -> VP8StatusCode;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
